public class RedBlackBST extends java.lang.Object
{
    private static final boolean RED;
    private static final boolean BLACK;
    private Node root;

    static void <clinit>()
    {
        boolean temp$0, temp$1;

        temp$0 = 1;

        <RedBlackBST: boolean RED> = temp$0;

        temp$1 = 0;

        <RedBlackBST: boolean BLACK> = temp$1;

        return;
    }

    public void <init>()
    {
        RedBlackBST this;

        this := @this: RedBlackBST;

        specialinvoke this.<java.lang.Object: void <init>()>();

        return;
    }

    private final boolean isRed(Node)
    {
        RedBlackBST this;
        Node x;
        boolean temp$0, temp$1, temp$2, temp$3;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 0;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: boolean color>;

        temp$2 = <RedBlackBST: boolean RED>;

        if temp$1 == temp$2 goto label4;

        goto label3;

     label3:
        nop;

        temp$3 = 0;

        goto label5;

     label4:
        nop;

        temp$3 = 1;

     label5:
        nop;

        return temp$3;
    }

    private final int size(Node)
    {
        RedBlackBST this;
        Node x;
        int temp$0, temp$1;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 0;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: int size>;

        return temp$1;
    }

    public int size()
    {
        RedBlackBST this;
        Node temp$0;
        int temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$0);

        return temp$1;
    }

    public boolean isEmpty()
    {
        RedBlackBST this;
        Node temp$0;
        boolean temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        if temp$0 == null goto label2;

        goto label1;

     label1:
        nop;

        temp$1 = 0;

        goto label3;

     label2:
        nop;

        temp$1 = 1;

     label3:
        nop;

        return temp$1;
    }

    public int get(int)
    {
        RedBlackBST this;
        int key, temp$0, temp$2;
        Node temp$1;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        temp$1 = this.<RedBlackBST: Node root>;

        temp$2 = virtualinvoke this.<RedBlackBST: int get(Node,int)>(temp$1, key);

        return temp$2;
    }

    private final int get(Node, int)
    {
        RedBlackBST this;
        Node x, temp$2, temp$3;
        int key, 'cmp', temp$0, temp$1, temp$4, temp$5;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        key := @parameter1: int;

     label1:
        nop;

        if x != null goto label2;

        goto label9;

     label2:
        nop;

        temp$0 = x.<Node: int key>;

        temp$1 = key - temp$0;

        'cmp' = temp$1;

        if 'cmp' < 0 goto label3;

        goto label4;

     label3:
        nop;

        temp$2 = x.<Node: Node left>;

        x = temp$2;

        goto label8;

     label4:
        nop;

        if 'cmp' > 0 goto label5;

        goto label6;

     label5:
        nop;

        temp$3 = x.<Node: Node right>;

        x = temp$3;

        goto label7;

     label6:
        nop;

        temp$4 = x.<Node: int val>;

        return temp$4;

     label7:
        nop;

     label8:
        nop;

        goto label1;

     label9:
        nop;

        temp$5 = 114514;

        return temp$5;
    }

    public boolean contains(int)
    {
        RedBlackBST this;
        int key, temp$0;
        boolean temp$1;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        temp$0 = virtualinvoke this.<RedBlackBST: int get(int)>(key);

        if temp$0 != 114514 goto label2;

        goto label1;

     label1:
        nop;

        temp$1 = 0;

        goto label3;

     label2:
        nop;

        temp$1 = 1;

     label3:
        nop;

        return temp$1;
    }

    public void put(int, int)
    {
        RedBlackBST this;
        int key, val;
        Node temp$0, temp$1, temp$2;
        boolean temp$3;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        val := @parameter1: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        return;

     label2:
        nop;

        if val == 114514 goto label3;

        goto label4;

     label3:
        nop;

        virtualinvoke this.<RedBlackBST: void delete(int)>(key);

        return;

     label4:
        nop;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: Node put(Node,int,int)>(temp$0, key, val);

        this.<RedBlackBST: Node root> = temp$1;

        temp$2 = this.<RedBlackBST: Node root>;

        temp$3 = 0;

        temp$2.<Node: boolean color> = temp$3;

        return;
    }

    private final Node put(Node, int, int)
    {
        RedBlackBST this;
        Node h, temp$0, temp$3, temp$4, temp$5, temp$6, temp$7, temp$9, temp$11, temp$12, temp$14, temp$15, temp$17, temp$18, temp$20, temp$22, temp$25;
        int key, val, 'cmp', temp$1, temp$2, temp$23, temp$24, temp$26, temp$27, temp$28;
        boolean temp$8, temp$10, temp$13, temp$16, temp$19, temp$21;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        key := @parameter1: int;

        val := @parameter2: int;

        if h == null goto label01;

        goto label02;

     label01:
        nop;

        temp$0 = new Node;

        specialinvoke temp$0.<Node: void <init>(int,int,boolean,int)>(key, val, 1, 1);

        return temp$0;

     label02:
        nop;

        temp$1 = h.<Node: int key>;

        temp$2 = key - temp$1;

        'cmp' = temp$2;

        if 'cmp' < 0 goto label03;

        goto label04;

     label03:
        nop;

        temp$3 = h.<Node: Node left>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node put(Node,int,int)>(temp$3, key, val);

        h.<Node: Node left> = temp$4;

        goto label08;

     label04:
        nop;

        if 'cmp' > 0 goto label05;

        goto label06;

     label05:
        nop;

        temp$5 = h.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: Node put(Node,int,int)>(temp$5, key, val);

        h.<Node: Node right> = temp$6;

        goto label07;

     label06:
        nop;

        h.<Node: int val> = val;

     label07:
        nop;

     label08:
        nop;

        temp$7 = h.<Node: Node right>;

        temp$8 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$7);

        if temp$8 == 0 goto label11;

        goto label09;

     label09:
        nop;

        temp$9 = h.<Node: Node left>;

        temp$10 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$9);

        if temp$10 == 0 goto label10;

        goto label11;

        goto label10;

     label10:
        nop;

        temp$11 = virtualinvoke this.<RedBlackBST: Node rotateLeft(Node)>(h);

        h = temp$11;

     label11:
        nop;

        temp$12 = h.<Node: Node left>;

        temp$13 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$12);

        if temp$13 == 0 goto label14;

        goto label12;

     label12:
        nop;

        temp$14 = h.<Node: Node left>;

        temp$15 = temp$14.<Node: Node left>;

        temp$16 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$15);

        if temp$16 == 0 goto label14;

        goto label13;

        goto label13;

     label13:
        nop;

        temp$17 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(h);

        h = temp$17;

     label14:
        nop;

        temp$18 = h.<Node: Node left>;

        temp$19 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$18);

        if temp$19 == 0 goto label17;

        goto label15;

     label15:
        nop;

        temp$20 = h.<Node: Node right>;

        temp$21 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$20);

        if temp$21 == 0 goto label17;

        goto label16;

        goto label16;

     label16:
        nop;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

     label17:
        nop;

        temp$22 = h.<Node: Node left>;

        temp$23 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$22);

        temp$24 = temp$23;

        temp$25 = h.<Node: Node right>;

        temp$26 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$25);

        temp$27 = temp$24 + temp$26;

        temp$28 = temp$27 + 1;

        h.<Node: int size> = temp$28;

        return h;
    }

    public void deleteMin()
    {
        RedBlackBST this;
        boolean temp$0, temp$3, temp$6, temp$8, temp$11, temp$13;
        Node temp$1, temp$2, temp$4, temp$5, temp$7, temp$9, temp$10, temp$12;

        this := @this: RedBlackBST;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$0 == 0 goto label2;

        goto label1;

     label1:
        nop;

        return;

     label2:
        nop;

        temp$1 = this.<RedBlackBST: Node root>;

        temp$2 = temp$1.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label3;

        goto label5;

     label3:
        nop;

        temp$4 = this.<RedBlackBST: Node root>;

        temp$5 = temp$4.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label4;

        goto label5;

        goto label4;

     label4:
        nop;

        temp$7 = this.<RedBlackBST: Node root>;

        temp$8 = 1;

        temp$7.<Node: boolean color> = temp$8;

     label5:
        nop;

        temp$9 = this.<RedBlackBST: Node root>;

        temp$10 = virtualinvoke this.<RedBlackBST: Node deleteMin(Node)>(temp$9);

        this.<RedBlackBST: Node root> = temp$10;

        temp$11 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$11 == 0 goto label6;

        goto label7;

     label6:
        nop;

        temp$12 = this.<RedBlackBST: Node root>;

        temp$13 = 0;

        temp$12.<Node: boolean color> = temp$13;

     label7:
        nop;

        return;
    }

    private final Node deleteMin(Node)
    {
        RedBlackBST this;
        Node h, temp$0, temp$1, temp$2, temp$4, temp$5, temp$7, temp$8, temp$9, temp$10;
        boolean temp$3, temp$6;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        temp$0 = h.<Node: Node left>;

        if temp$0 == null goto label1;

        goto label2;

     label1:
        nop;

        temp$1 = null;

        return temp$1;

     label2:
        nop;

        temp$2 = h.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label3;

        goto label5;

     label3:
        nop;

        temp$4 = h.<Node: Node left>;

        temp$5 = temp$4.<Node: Node left>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label4;

        goto label5;

        goto label4;

     label4:
        nop;

        temp$7 = virtualinvoke this.<RedBlackBST: Node moveRedLeft(Node)>(h);

        h = temp$7;

     label5:
        nop;

        temp$8 = h.<Node: Node left>;

        temp$9 = virtualinvoke this.<RedBlackBST: Node deleteMin(Node)>(temp$8);

        h.<Node: Node left> = temp$9;

        temp$10 = virtualinvoke this.<RedBlackBST: Node balance(Node)>(h);

        return temp$10;
    }

    public void deleteMax()
    {
        RedBlackBST this;
        boolean temp$0, temp$3, temp$6, temp$8, temp$11, temp$13;
        Node temp$1, temp$2, temp$4, temp$5, temp$7, temp$9, temp$10, temp$12;

        this := @this: RedBlackBST;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$0 == 0 goto label2;

        goto label1;

     label1:
        nop;

        return;

     label2:
        nop;

        temp$1 = this.<RedBlackBST: Node root>;

        temp$2 = temp$1.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label3;

        goto label5;

     label3:
        nop;

        temp$4 = this.<RedBlackBST: Node root>;

        temp$5 = temp$4.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label4;

        goto label5;

        goto label4;

     label4:
        nop;

        temp$7 = this.<RedBlackBST: Node root>;

        temp$8 = 1;

        temp$7.<Node: boolean color> = temp$8;

     label5:
        nop;

        temp$9 = this.<RedBlackBST: Node root>;

        temp$10 = virtualinvoke this.<RedBlackBST: Node deleteMax(Node)>(temp$9);

        this.<RedBlackBST: Node root> = temp$10;

        temp$11 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$11 == 0 goto label6;

        goto label7;

     label6:
        nop;

        temp$12 = this.<RedBlackBST: Node root>;

        temp$13 = 0;

        temp$12.<Node: boolean color> = temp$13;

     label7:
        nop;

        return;
    }

    private final Node deleteMax(Node)
    {
        RedBlackBST this;
        Node h, temp$0, temp$2, temp$3, temp$4, temp$5, temp$7, temp$8, temp$10, temp$11, temp$12, temp$13;
        boolean temp$1, temp$6, temp$9;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        temp$0 = h.<Node: Node left>;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$0);

        if temp$1 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$2 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(h);

        h = temp$2;

     label2:
        nop;

        temp$3 = h.<Node: Node right>;

        if temp$3 == null goto label3;

        goto label4;

     label3:
        nop;

        temp$4 = null;

        return temp$4;

     label4:
        nop;

        temp$5 = h.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label5;

        goto label7;

     label5:
        nop;

        temp$7 = h.<Node: Node right>;

        temp$8 = temp$7.<Node: Node left>;

        temp$9 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$8);

        if temp$9 == 0 goto label6;

        goto label7;

        goto label6;

     label6:
        nop;

        temp$10 = virtualinvoke this.<RedBlackBST: Node moveRedRight(Node)>(h);

        h = temp$10;

     label7:
        nop;

        temp$11 = h.<Node: Node right>;

        temp$12 = virtualinvoke this.<RedBlackBST: Node deleteMax(Node)>(temp$11);

        h.<Node: Node right> = temp$12;

        temp$13 = virtualinvoke this.<RedBlackBST: Node balance(Node)>(h);

        return temp$13;
    }

    public void delete(int)
    {
        RedBlackBST this;
        int key;
        boolean temp$0, temp$3, temp$6, temp$8, temp$11, temp$13;
        Node temp$1, temp$2, temp$4, temp$5, temp$7, temp$9, temp$10, temp$12;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        return;

     label2:
        nop;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean contains(int)>(key);

        if temp$0 == 0 goto label3;

        goto label4;

     label3:
        nop;

        return;

     label4:
        nop;

        temp$1 = this.<RedBlackBST: Node root>;

        temp$2 = temp$1.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label5;

        goto label7;

     label5:
        nop;

        temp$4 = this.<RedBlackBST: Node root>;

        temp$5 = temp$4.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label6;

        goto label7;

        goto label6;

     label6:
        nop;

        temp$7 = this.<RedBlackBST: Node root>;

        temp$8 = 1;

        temp$7.<Node: boolean color> = temp$8;

     label7:
        nop;

        temp$9 = this.<RedBlackBST: Node root>;

        temp$10 = virtualinvoke this.<RedBlackBST: Node delete(Node,int)>(temp$9, key);

        this.<RedBlackBST: Node root> = temp$10;

        temp$11 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$11 == 0 goto label8;

        goto label9;

     label8:
        nop;

        temp$12 = this.<RedBlackBST: Node root>;

        temp$13 = 0;

        temp$12.<Node: boolean color> = temp$13;

     label9:
        nop;

        return;
    }

    private final Node delete(Node, int)
    {
        RedBlackBST this;
        Node h, temp$2, temp$4, temp$5, temp$7, temp$8, temp$9, temp$10, temp$12, temp$15, temp$16, temp$17, temp$19, temp$20, temp$22, x, temp$25, temp$26, temp$29, temp$30, temp$31, temp$32, temp$33;
        int key, temp$0, temp$1, temp$13, temp$14, temp$23, temp$24, temp$27, temp$28;
        boolean temp$3, temp$6, temp$11, temp$18, temp$21;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        key := @parameter1: int;

        temp$0 = h.<Node: int key>;

        temp$1 = key - temp$0;

        if temp$1 < 0 goto label01;

        goto label05;

     label01:
        nop;

        temp$2 = h.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label02;

        goto label04;

     label02:
        nop;

        temp$4 = h.<Node: Node left>;

        temp$5 = temp$4.<Node: Node left>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label03;

        goto label04;

        goto label03;

     label03:
        nop;

        temp$7 = virtualinvoke this.<RedBlackBST: Node moveRedLeft(Node)>(h);

        h = temp$7;

     label04:
        nop;

        temp$8 = h.<Node: Node left>;

        temp$9 = virtualinvoke this.<RedBlackBST: Node delete(Node,int)>(temp$8, key);

        h.<Node: Node left> = temp$9;

        goto label17;

     label05:
        nop;

        temp$10 = h.<Node: Node left>;

        temp$11 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$10);

        if temp$11 == 0 goto label07;

        goto label06;

     label06:
        nop;

        temp$12 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(h);

        h = temp$12;

     label07:
        nop;

        temp$13 = h.<Node: int key>;

        temp$14 = key - temp$13;

        if temp$14 == 0 goto label08;

        goto label10;

     label08:
        nop;

        temp$15 = h.<Node: Node right>;

        if temp$15 == null goto label09;

        goto label10;

        goto label09;

     label09:
        nop;

        temp$16 = null;

        return temp$16;

     label10:
        nop;

        temp$17 = h.<Node: Node right>;

        temp$18 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$17);

        if temp$18 == 0 goto label11;

        goto label13;

     label11:
        nop;

        temp$19 = h.<Node: Node right>;

        temp$20 = temp$19.<Node: Node left>;

        temp$21 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$20);

        if temp$21 == 0 goto label12;

        goto label13;

        goto label12;

     label12:
        nop;

        temp$22 = virtualinvoke this.<RedBlackBST: Node moveRedRight(Node)>(h);

        h = temp$22;

     label13:
        nop;

        temp$23 = h.<Node: int key>;

        temp$24 = key - temp$23;

        if temp$24 == 0 goto label14;

        goto label15;

     label14:
        nop;

        temp$25 = h.<Node: Node right>;

        temp$26 = virtualinvoke this.<RedBlackBST: Node min(Node)>(temp$25);

        x = temp$26;

        temp$27 = x.<Node: int key>;

        h.<Node: int key> = temp$27;

        temp$28 = x.<Node: int val>;

        h.<Node: int val> = temp$28;

        temp$29 = h.<Node: Node right>;

        temp$30 = virtualinvoke this.<RedBlackBST: Node deleteMin(Node)>(temp$29);

        h.<Node: Node right> = temp$30;

        goto label16;

     label15:
        nop;

        temp$31 = h.<Node: Node right>;

        temp$32 = virtualinvoke this.<RedBlackBST: Node delete(Node,int)>(temp$31, key);

        h.<Node: Node right> = temp$32;

     label16:
        nop;

     label17:
        nop;

        temp$33 = virtualinvoke this.<RedBlackBST: Node balance(Node)>(h);

        return temp$33;
    }

    private final Node rotateRight(Node)
    {
        RedBlackBST this;
        Node h, x, temp$0, temp$1, temp$3, temp$6, temp$9;
        boolean temp$2, temp$4;
        int temp$5, temp$7, temp$8, temp$10, temp$11, temp$12;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        x = h.<Node: Node left>;

        temp$0 = x.<Node: Node right>;

        h.<Node: Node left> = temp$0;

        x.<Node: Node right> = h;

        temp$1 = x.<Node: Node right>;

        temp$2 = temp$1.<Node: boolean color>;

        x.<Node: boolean color> = temp$2;

        temp$3 = x.<Node: Node right>;

        temp$4 = 1;

        temp$3.<Node: boolean color> = temp$4;

        temp$5 = h.<Node: int size>;

        x.<Node: int size> = temp$5;

        temp$6 = h.<Node: Node left>;

        temp$7 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$6);

        temp$8 = temp$7;

        temp$9 = h.<Node: Node right>;

        temp$10 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$9);

        temp$11 = temp$8 + temp$10;

        temp$12 = temp$11 + 1;

        h.<Node: int size> = temp$12;

        return x;
    }

    private final Node rotateLeft(Node)
    {
        RedBlackBST this;
        Node h, x, temp$0, temp$1, temp$3, temp$6, temp$9;
        boolean temp$2, temp$4;
        int temp$5, temp$7, temp$8, temp$10, temp$11, temp$12;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        x = h.<Node: Node right>;

        temp$0 = x.<Node: Node left>;

        h.<Node: Node right> = temp$0;

        x.<Node: Node left> = h;

        temp$1 = x.<Node: Node left>;

        temp$2 = temp$1.<Node: boolean color>;

        x.<Node: boolean color> = temp$2;

        temp$3 = x.<Node: Node left>;

        temp$4 = 1;

        temp$3.<Node: boolean color> = temp$4;

        temp$5 = h.<Node: int size>;

        x.<Node: int size> = temp$5;

        temp$6 = h.<Node: Node left>;

        temp$7 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$6);

        temp$8 = temp$7;

        temp$9 = h.<Node: Node right>;

        temp$10 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$9);

        temp$11 = temp$8 + temp$10;

        temp$12 = temp$11 + 1;

        h.<Node: int size> = temp$12;

        return x;
    }

    private final void flipColors(Node)
    {
        RedBlackBST this;
        Node h, temp$2, temp$3, temp$6, temp$7;
        boolean temp$0, temp$1, temp$4, temp$5, temp$8, temp$9;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        temp$0 = h.<Node: boolean color>;

        if temp$0 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$1 = 0;

        goto label3;

     label2:
        nop;

        temp$1 = 1;

     label3:
        nop;

        h.<Node: boolean color> = temp$1;

        temp$2 = h.<Node: Node left>;

        temp$3 = h.<Node: Node left>;

        temp$4 = temp$3.<Node: boolean color>;

        if temp$4 == 0 goto label5;

        goto label4;

     label4:
        nop;

        temp$5 = 0;

        goto label6;

     label5:
        nop;

        temp$5 = 1;

     label6:
        nop;

        temp$2.<Node: boolean color> = temp$5;

        temp$6 = h.<Node: Node right>;

        temp$7 = h.<Node: Node right>;

        temp$8 = temp$7.<Node: boolean color>;

        if temp$8 == 0 goto label8;

        goto label7;

     label7:
        nop;

        temp$9 = 0;

        goto label9;

     label8:
        nop;

        temp$9 = 1;

     label9:
        nop;

        temp$6.<Node: boolean color> = temp$9;

        return;
    }

    private final Node moveRedLeft(Node)
    {
        RedBlackBST this;
        Node h, temp$0, temp$1, temp$3, temp$4, temp$5;
        boolean temp$2;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

        temp$0 = h.<Node: Node right>;

        temp$1 = temp$0.<Node: Node left>;

        temp$2 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$1);

        if temp$2 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$3 = h.<Node: Node right>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(temp$3);

        h.<Node: Node right> = temp$4;

        temp$5 = virtualinvoke this.<RedBlackBST: Node rotateLeft(Node)>(h);

        h = temp$5;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

     label2:
        nop;

        return h;
    }

    private final Node moveRedRight(Node)
    {
        RedBlackBST this;
        Node h, temp$0, temp$1, temp$3;
        boolean temp$2;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

        temp$0 = h.<Node: Node left>;

        temp$1 = temp$0.<Node: Node left>;

        temp$2 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$1);

        if temp$2 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$3 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(h);

        h = temp$3;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

     label2:
        nop;

        return h;
    }

    private final Node balance(Node)
    {
        RedBlackBST this;
        Node h, temp$0, temp$2, temp$4, temp$5, temp$7, temp$8, temp$10, temp$11, temp$13, temp$15, temp$18;
        boolean temp$1, temp$3, temp$6, temp$9, temp$12, temp$14;
        int temp$16, temp$17, temp$19, temp$20, temp$21;

        this := @this: RedBlackBST;

        h := @parameter0: Node;

        temp$0 = h.<Node: Node right>;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$0);

        if temp$1 == 0 goto label3;

        goto label1;

     label1:
        nop;

        temp$2 = h.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$2);

        if temp$3 == 0 goto label2;

        goto label3;

        goto label2;

     label2:
        nop;

        temp$4 = virtualinvoke this.<RedBlackBST: Node rotateLeft(Node)>(h);

        h = temp$4;

     label3:
        nop;

        temp$5 = h.<Node: Node left>;

        temp$6 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$5);

        if temp$6 == 0 goto label6;

        goto label4;

     label4:
        nop;

        temp$7 = h.<Node: Node left>;

        temp$8 = temp$7.<Node: Node left>;

        temp$9 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$8);

        if temp$9 == 0 goto label6;

        goto label5;

        goto label5;

     label5:
        nop;

        temp$10 = virtualinvoke this.<RedBlackBST: Node rotateRight(Node)>(h);

        h = temp$10;

     label6:
        nop;

        temp$11 = h.<Node: Node left>;

        temp$12 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$11);

        if temp$12 == 0 goto label9;

        goto label7;

     label7:
        nop;

        temp$13 = h.<Node: Node right>;

        temp$14 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$13);

        if temp$14 == 0 goto label9;

        goto label8;

        goto label8;

     label8:
        nop;

        virtualinvoke this.<RedBlackBST: void flipColors(Node)>(h);

     label9:
        nop;

        temp$15 = h.<Node: Node left>;

        temp$16 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$15);

        temp$17 = temp$16;

        temp$18 = h.<Node: Node right>;

        temp$19 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$18);

        temp$20 = temp$17 + temp$19;

        temp$21 = temp$20 + 1;

        h.<Node: int size> = temp$21;

        return h;
    }

    public int height()
    {
        RedBlackBST this;
        Node temp$0;
        int temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: int height(Node)>(temp$0);

        return temp$1;
    }

    private final int height(Node)
    {
        RedBlackBST this;
        Node x, temp$2, temp$4;
        int temp$0, temp$1, temp$3, temp$5, temp$6, temp$7;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = -1;

        return temp$0;

     label2:
        nop;

        temp$1 = 1;

        temp$2 = x.<Node: Node left>;

        temp$3 = virtualinvoke this.<RedBlackBST: int height(Node)>(temp$2);

        temp$4 = x.<Node: Node right>;

        temp$5 = virtualinvoke this.<RedBlackBST: int height(Node)>(temp$4);

        temp$6 = staticinvoke <java.lang.Math: int max(int,int)>(temp$3, temp$5);

        temp$7 = temp$1 + temp$6;

        return temp$7;
    }

    public int min()
    {
        RedBlackBST this;
        boolean temp$0;
        int temp$1, temp$4;
        Node temp$2, temp$3;

        this := @this: RedBlackBST;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$0 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$1 = 114514;

        return temp$1;

     label2:
        nop;

        temp$2 = this.<RedBlackBST: Node root>;

        temp$3 = virtualinvoke this.<RedBlackBST: Node min(Node)>(temp$2);

        temp$4 = temp$3.<Node: int key>;

        return temp$4;
    }

    private final Node min(Node)
    {
        RedBlackBST this;
        Node x, temp$0, temp$1, temp$2;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        temp$0 = x.<Node: Node left>;

        if temp$0 == null goto label1;

        goto label2;

     label1:
        nop;

        return x;

     label2:
        nop;

        temp$1 = x.<Node: Node left>;

        temp$2 = virtualinvoke this.<RedBlackBST: Node min(Node)>(temp$1);

        return temp$2;
    }

    public int max()
    {
        RedBlackBST this;
        boolean temp$0;
        int temp$1, temp$4;
        Node temp$2, temp$3;

        this := @this: RedBlackBST;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$0 == 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$1 = 114514;

        return temp$1;

     label2:
        nop;

        temp$2 = this.<RedBlackBST: Node root>;

        temp$3 = virtualinvoke this.<RedBlackBST: Node max(Node)>(temp$2);

        temp$4 = temp$3.<Node: int key>;

        return temp$4;
    }

    private final Node max(Node)
    {
        RedBlackBST this;
        Node x, temp$0, temp$1, temp$2;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        temp$0 = x.<Node: Node right>;

        if temp$0 == null goto label1;

        goto label2;

     label1:
        nop;

        return x;

     label2:
        nop;

        temp$1 = x.<Node: Node right>;

        temp$2 = virtualinvoke this.<RedBlackBST: Node max(Node)>(temp$1);

        return temp$2;
    }

    public int floor(int)
    {
        RedBlackBST this;
        int key, temp$0, temp$2, temp$5, temp$6;
        boolean temp$1;
        Node x, temp$3, temp$4;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$1 == 0 goto label4;

        goto label3;

     label3:
        nop;

        temp$2 = 114514;

        return temp$2;

     label4:
        nop;

        temp$3 = this.<RedBlackBST: Node root>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node floor(Node,int)>(temp$3, key);

        x = temp$4;

        if x == null goto label5;

        goto label6;

     label5:
        nop;

        temp$5 = 114514;

        return temp$5;

     label6:
        nop;

        temp$6 = x.<Node: int key>;

        return temp$6;
    }

    private final Node floor(Node, int)
    {
        RedBlackBST this;
        Node x, temp$0, temp$3, temp$4, t, temp$5, temp$6;
        int key, 'cmp', temp$1, temp$2;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        key := @parameter1: int;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = null;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: int key>;

        temp$2 = key - temp$1;

        'cmp' = temp$2;

        if 'cmp' == 0 goto label3;

        goto label4;

     label3:
        nop;

        return x;

     label4:
        nop;

        if 'cmp' < 0 goto label5;

        goto label6;

     label5:
        nop;

        temp$3 = x.<Node: Node left>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node floor(Node,int)>(temp$3, key);

        return temp$4;

     label6:
        nop;

        temp$5 = x.<Node: Node right>;

        temp$6 = virtualinvoke this.<RedBlackBST: Node floor(Node,int)>(temp$5, key);

        t = temp$6;

        if t != null goto label7;

        goto label8;

     label7:
        nop;

        return t;

     label8:
        nop;

        return x;
    }

    public int ceiling(int)
    {
        RedBlackBST this;
        int key, temp$0, temp$2, temp$5, temp$6;
        boolean temp$1;
        Node x, temp$3, temp$4;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isEmpty()>();

        if temp$1 == 0 goto label4;

        goto label3;

     label3:
        nop;

        temp$2 = 114514;

        return temp$2;

     label4:
        nop;

        temp$3 = this.<RedBlackBST: Node root>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node ceiling(Node,int)>(temp$3, key);

        x = temp$4;

        if x == null goto label5;

        goto label6;

     label5:
        nop;

        temp$5 = 114514;

        return temp$5;

     label6:
        nop;

        temp$6 = x.<Node: int key>;

        return temp$6;
    }

    private final Node ceiling(Node, int)
    {
        RedBlackBST this;
        Node x, temp$0, temp$3, temp$4, t, temp$5, temp$6;
        int key, 'cmp', temp$1, temp$2;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        key := @parameter1: int;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = null;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: int key>;

        temp$2 = key - temp$1;

        'cmp' = temp$2;

        if 'cmp' == 0 goto label3;

        goto label4;

     label3:
        nop;

        return x;

     label4:
        nop;

        if 'cmp' > 0 goto label5;

        goto label6;

     label5:
        nop;

        temp$3 = x.<Node: Node right>;

        temp$4 = virtualinvoke this.<RedBlackBST: Node ceiling(Node,int)>(temp$3, key);

        return temp$4;

     label6:
        nop;

        temp$5 = x.<Node: Node left>;

        temp$6 = virtualinvoke this.<RedBlackBST: Node ceiling(Node,int)>(temp$5, key);

        t = temp$6;

        if t != null goto label7;

        goto label8;

     label7:
        nop;

        return t;

     label8:
        nop;

        return x;
    }

    public int select(int)
    {
        RedBlackBST this;
        int rank, temp$0, temp$1, temp$3;
        Node temp$2;

        this := @this: RedBlackBST;

        rank := @parameter0: int;

        if rank < 0 goto label2;

        goto label1;

     label1:
        nop;

        temp$0 = virtualinvoke this.<RedBlackBST: int size()>();

        if rank >= temp$0 goto label2;

        goto label3;

        goto label3;

     label2:
        nop;

        temp$1 = 114514;

        return temp$1;

     label3:
        nop;

        temp$2 = this.<RedBlackBST: Node root>;

        temp$3 = virtualinvoke this.<RedBlackBST: int select(Node,int)>(temp$2, rank);

        return temp$3;
    }

    private final int select(Node, int)
    {
        RedBlackBST this;
        Node x, temp$1, temp$3, temp$5;
        int rank, temp$0, leftSize, temp$2, temp$4, temp$6, temp$7, temp$8, temp$9;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        rank := @parameter1: int;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: Node left>;

        temp$2 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$1);

        leftSize = temp$2;

        if leftSize > rank goto label3;

        goto label4;

     label3:
        nop;

        temp$3 = x.<Node: Node left>;

        temp$4 = virtualinvoke this.<RedBlackBST: int select(Node,int)>(temp$3, rank);

        return temp$4;

     label4:
        nop;

        if leftSize < rank goto label5;

        goto label6;

     label5:
        nop;

        temp$5 = x.<Node: Node right>;

        temp$6 = rank - leftSize;

        temp$7 = temp$6 - 1;

        temp$8 = virtualinvoke this.<RedBlackBST: int select(Node,int)>(temp$5, temp$7);

        return temp$8;

     label6:
        nop;

        temp$9 = x.<Node: int key>;

        return temp$9;
    }

    public int rank(int)
    {
        RedBlackBST this;
        int key, temp$0, temp$2;
        Node temp$1;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        if key == 114514 goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        temp$1 = this.<RedBlackBST: Node root>;

        temp$2 = virtualinvoke this.<RedBlackBST: int rank(int,Node)>(key, temp$1);

        return temp$2;
    }

    private final int rank(int, Node)
    {
        RedBlackBST this;
        int key, temp$0, 'cmp', temp$1, temp$2, temp$4, temp$5, temp$7, temp$8, temp$10, temp$11, temp$13;
        Node x, temp$3, temp$6, temp$9, temp$12;

        this := @this: RedBlackBST;

        key := @parameter0: int;

        x := @parameter1: Node;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 0;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: int key>;

        temp$2 = key - temp$1;

        'cmp' = temp$2;

        if 'cmp' < 0 goto label3;

        goto label4;

     label3:
        nop;

        temp$3 = x.<Node: Node left>;

        temp$4 = virtualinvoke this.<RedBlackBST: int rank(int,Node)>(key, temp$3);

        return temp$4;

     label4:
        nop;

        if 'cmp' > 0 goto label5;

        goto label6;

     label5:
        nop;

        temp$5 = 1;

        temp$6 = x.<Node: Node left>;

        temp$7 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$6);

        temp$8 = temp$5 + temp$7;

        temp$9 = x.<Node: Node right>;

        temp$10 = virtualinvoke this.<RedBlackBST: int rank(int,Node)>(key, temp$9);

        temp$11 = temp$8 + temp$10;

        return temp$11;

     label6:
        nop;

        temp$12 = x.<Node: Node left>;

        temp$13 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$12);

        return temp$13;
    }

    public int size(int, int)
    {
        RedBlackBST this;
        int lo, hi, temp$0, temp$1, temp$2, temp$3, temp$5, temp$6, temp$7, temp$8, temp$9, temp$10, temp$11, temp$12;
        boolean temp$4;

        this := @this: RedBlackBST;

        lo := @parameter0: int;

        hi := @parameter1: int;

        if lo == 114514 goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 114514;

        return temp$0;

     label2:
        nop;

        if hi == 114514 goto label3;

        goto label4;

     label3:
        nop;

        temp$1 = 114514;

        return temp$1;

     label4:
        nop;

        temp$2 = lo - hi;

        if temp$2 > 0 goto label5;

        goto label6;

     label5:
        nop;

        temp$3 = 0;

        return temp$3;

     label6:
        nop;

        temp$4 = virtualinvoke this.<RedBlackBST: boolean contains(int)>(hi);

        if temp$4 == 0 goto label8;

        goto label7;

     label7:
        nop;

        temp$5 = virtualinvoke this.<RedBlackBST: int rank(int)>(hi);

        temp$6 = virtualinvoke this.<RedBlackBST: int rank(int)>(lo);

        temp$7 = temp$5 - temp$6;

        temp$8 = temp$7;

        temp$9 = temp$8 + 1;

        return temp$9;

     label8:
        nop;

        temp$10 = virtualinvoke this.<RedBlackBST: int rank(int)>(hi);

        temp$11 = virtualinvoke this.<RedBlackBST: int rank(int)>(lo);

        temp$12 = temp$10 - temp$11;

        return temp$12;
    }

    private final boolean check()
    {
        RedBlackBST this;
        boolean temp$0, temp$1, temp$2, temp$3, temp$4;

        this := @this: RedBlackBST;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isBST()>();

        if temp$0 == 0 goto label4;

        goto label1;

     label1:
        nop;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isSizeConsistent()>();

        if temp$1 == 0 goto label4;

        goto label2;

        goto label2;

     label2:
        nop;

        temp$2 = virtualinvoke this.<RedBlackBST: boolean is23()>();

        if temp$2 == 0 goto label4;

        goto label3;

        goto label3;

     label3:
        nop;

        temp$3 = virtualinvoke this.<RedBlackBST: boolean isBalanced()>();

        if temp$3 == 0 goto label4;

        goto label5;

        goto label5;

     label4:
        nop;

        temp$4 = 0;

        goto label6;

     label5:
        nop;

        temp$4 = 1;

     label6:
        nop;

        return temp$4;
    }

    private final boolean isBST()
    {
        RedBlackBST this;
        Node temp$0;
        boolean temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isBST(Node,int,int)>(temp$0, 114514, 114514);

        return temp$1;
    }

    private final boolean isBST(Node, int, int)
    {
        RedBlackBST this;
        Node x, temp$7, temp$10;
        int min, max, temp$1, temp$2, temp$4, temp$5, temp$8, temp$11;
        boolean temp$0, temp$3, temp$6, temp$9, temp$12, temp$13;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        min := @parameter1: int;

        max := @parameter2: int;

        if x == null goto label01;

        goto label02;

     label01:
        nop;

        temp$0 = 1;

        return temp$0;

     label02:
        nop;

        if min != 114514 goto label03;

        goto label05;

     label03:
        nop;

        temp$1 = x.<Node: int key>;

        temp$2 = temp$1 - min;

        if temp$2 <= 0 goto label04;

        goto label05;

        goto label04;

     label04:
        nop;

        temp$3 = 0;

        return temp$3;

     label05:
        nop;

        if max != 114514 goto label06;

        goto label08;

     label06:
        nop;

        temp$4 = x.<Node: int key>;

        temp$5 = temp$4 - max;

        if temp$5 >= 0 goto label07;

        goto label08;

        goto label07;

     label07:
        nop;

        temp$6 = 0;

        return temp$6;

     label08:
        nop;

        temp$7 = x.<Node: Node left>;

        temp$8 = x.<Node: int key>;

        temp$9 = virtualinvoke this.<RedBlackBST: boolean isBST(Node,int,int)>(temp$7, min, temp$8);

        if temp$9 == 0 goto label10;

        goto label09;

     label09:
        nop;

        temp$10 = x.<Node: Node right>;

        temp$11 = x.<Node: int key>;

        temp$12 = virtualinvoke this.<RedBlackBST: boolean isBST(Node,int,int)>(temp$10, temp$11, max);

        if temp$12 == 0 goto label10;

        goto label11;

        goto label11;

     label10:
        nop;

        temp$13 = 0;

        goto label12;

     label11:
        nop;

        temp$13 = 1;

     label12:
        nop;

        return temp$13;
    }

    private final boolean isSizeConsistent()
    {
        RedBlackBST this;
        Node temp$0;
        boolean temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isSizeConsistent(Node)>(temp$0);

        return temp$1;
    }

    private final boolean isSizeConsistent(Node)
    {
        RedBlackBST this;
        Node x, temp$1, temp$4, temp$10, temp$12;
        boolean temp$0, temp$9, temp$11, temp$13, temp$14;
        int temp$2, temp$3, temp$5, temp$6, temp$7, temp$8;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        if x == null goto label1;

        goto label2;

     label1:
        nop;

        temp$0 = 1;

        return temp$0;

     label2:
        nop;

        temp$1 = x.<Node: Node left>;

        temp$2 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$1);

        temp$3 = temp$2;

        temp$4 = x.<Node: Node right>;

        temp$5 = virtualinvoke this.<RedBlackBST: int size(Node)>(temp$4);

        temp$6 = temp$3 + temp$5;

        temp$7 = x.<Node: int size>;

        temp$8 = temp$6 + 1;

        if temp$7 != temp$8 goto label3;

        goto label4;

     label3:
        nop;

        temp$9 = 0;

        return temp$9;

     label4:
        nop;

        temp$10 = x.<Node: Node left>;

        temp$11 = virtualinvoke this.<RedBlackBST: boolean isSizeConsistent(Node)>(temp$10);

        if temp$11 == 0 goto label6;

        goto label5;

     label5:
        nop;

        temp$12 = x.<Node: Node right>;

        temp$13 = virtualinvoke this.<RedBlackBST: boolean isSizeConsistent(Node)>(temp$12);

        if temp$13 == 0 goto label6;

        goto label7;

        goto label7;

     label6:
        nop;

        temp$14 = 0;

        goto label8;

     label7:
        nop;

        temp$14 = 1;

     label8:
        nop;

        return temp$14;
    }

    private final boolean is23()
    {
        RedBlackBST this;
        Node temp$0;
        boolean temp$1;

        this := @this: RedBlackBST;

        temp$0 = this.<RedBlackBST: Node root>;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean is23(Node)>(temp$0);

        return temp$1;
    }

    private final boolean is23(Node)
    {
        RedBlackBST this;
        Node x, temp$1, temp$4, temp$6, temp$9, temp$11;
        boolean temp$0, temp$2, temp$3, temp$5, temp$7, temp$8, temp$10, temp$12, temp$13;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        if x == null goto label01;

        goto label02;

     label01:
        nop;

        temp$0 = 1;

        return temp$0;

     label02:
        nop;

        temp$1 = x.<Node: Node right>;

        temp$2 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$1);

        if temp$2 == 0 goto label04;

        goto label03;

     label03:
        nop;

        temp$3 = 0;

        return temp$3;

     label04:
        nop;

        temp$4 = this.<RedBlackBST: Node root>;

        if x != temp$4 goto label05;

        goto label08;

     label05:
        nop;

        temp$5 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(x);

        if temp$5 == 0 goto label08;

        goto label06;

        goto label06;

     label06:
        nop;

        temp$6 = x.<Node: Node left>;

        temp$7 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(temp$6);

        if temp$7 == 0 goto label08;

        goto label07;

        goto label07;

     label07:
        nop;

        temp$8 = 0;

        return temp$8;

     label08:
        nop;

        temp$9 = x.<Node: Node left>;

        temp$10 = virtualinvoke this.<RedBlackBST: boolean is23(Node)>(temp$9);

        if temp$10 == 0 goto label10;

        goto label09;

     label09:
        nop;

        temp$11 = x.<Node: Node right>;

        temp$12 = virtualinvoke this.<RedBlackBST: boolean is23(Node)>(temp$11);

        if temp$12 == 0 goto label10;

        goto label11;

        goto label11;

     label10:
        nop;

        temp$13 = 0;

        goto label12;

     label11:
        nop;

        temp$13 = 1;

     label12:
        nop;

        return temp$13;
    }

    private final boolean isBalanced()
    {
        RedBlackBST this;
        int black, temp$1, temp$2;
        Node x, temp$3, temp$4;
        boolean temp$0, temp$5;

        this := @this: RedBlackBST;

        black = 0;

        x = this.<RedBlackBST: Node root>;

     label1:
        nop;

        if x != null goto label2;

        goto label5;

     label2:
        nop;

        temp$0 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(x);

        if temp$0 == 0 goto label3;

        goto label4;

     label3:
        nop;

        temp$1 = black;

        temp$2 = temp$1 + 1;

        black = temp$2;

     label4:
        nop;

        temp$3 = x.<Node: Node left>;

        x = temp$3;

        goto label1;

     label5:
        nop;

        temp$4 = this.<RedBlackBST: Node root>;

        temp$5 = virtualinvoke this.<RedBlackBST: boolean isBalanced(Node,int)>(temp$4, black);

        return temp$5;
    }

    private final boolean isBalanced(Node, int)
    {
        RedBlackBST this;
        Node x, temp$4, temp$6;
        int black, temp$2, temp$3;
        boolean temp$0, temp$1, temp$5, temp$7, temp$8;

        this := @this: RedBlackBST;

        x := @parameter0: Node;

        black := @parameter1: int;

        if x == null goto label01;

        goto label05;

     label01:
        nop;

        if black == 0 goto label03;

        goto label02;

     label02:
        nop;

        temp$0 = 0;

        goto label04;

     label03:
        nop;

        temp$0 = 1;

     label04:
        nop;

        return temp$0;

     label05:
        nop;

        temp$1 = virtualinvoke this.<RedBlackBST: boolean isRed(Node)>(x);

        if temp$1 == 0 goto label06;

        goto label07;

     label06:
        nop;

        temp$2 = black;

        temp$3 = temp$2 + -1;

        black = temp$3;

     label07:
        nop;

        temp$4 = x.<Node: Node left>;

        temp$5 = virtualinvoke this.<RedBlackBST: boolean isBalanced(Node,int)>(temp$4, black);

        if temp$5 == 0 goto label09;

        goto label08;

     label08:
        nop;

        temp$6 = x.<Node: Node right>;

        temp$7 = virtualinvoke this.<RedBlackBST: boolean isBalanced(Node,int)>(temp$6, black);

        if temp$7 == 0 goto label09;

        goto label10;

        goto label10;

     label09:
        nop;

        temp$8 = 0;

        goto label11;

     label10:
        nop;

        temp$8 = 1;

     label11:
        nop;

        return temp$8;
    }

    public static void main(java.lang.String[])
    {
        java.lang.String[] args;
        RedBlackBST st, temp$0;
        boolean temp$1;

        args := @parameter0: java.lang.String[];

        temp$0 = new RedBlackBST;

        specialinvoke temp$0.<RedBlackBST: void <init>()>();

        st = temp$0;

        virtualinvoke st.<RedBlackBST: void put(int,int)>(1, 2);

        virtualinvoke st.<RedBlackBST: void put(int,int)>(114, 514);

        virtualinvoke st.<RedBlackBST: void delete(int)>(3);

        temp$1 = virtualinvoke st.<RedBlackBST: boolean check()>();

        return;
    }
}
